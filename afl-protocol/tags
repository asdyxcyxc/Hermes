!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AFL_MAIN	afl-fuzz.c	23;"	d	file:
AFL_READ_FAKE	hook/hook.c	20;"	d	file:
AFL_READ_TARGET	hook/hook.c	17;"	d	file:
AFL_WRITE_FAKE	hook/hook.c	12;"	d	file:
CASE_PREFIX	afl-fuzz.c	3003;"	d	file:
CHK_FORMAT	afl-fuzz.c	565;"	d	file:
CHK_FORMAT	afl-fuzz.c	676;"	d	file:
DF	afl-fuzz.c	/^static u8* DF(double val) {$/;"	f	file:
DI	afl-fuzz.c	/^static u8* DI(u64 val) {$/;"	f	file:
DMS	afl-fuzz.c	/^static u8* DMS(u64 val) {$/;"	f	file:
DTD	afl-fuzz.c	/^static u8* DTD(u64 cur_ms, u64 event_ms) {$/;"	f	file:
EFF_ALEN	afl-fuzz.c	5362;"	d	file:
EFF_APOS	afl-fuzz.c	5360;"	d	file:
EFF_REM	afl-fuzz.c	5361;"	d	file:
EFF_SPAN_ALEN	afl-fuzz.c	5363;"	d	file:
EXP_ST	afl-fuzz.c	77;"	d	file:
EXP_ST	afl-fuzz.c	79;"	d	file:
FAKE_READ_AFL	hook/hook.c	11;"	d	file:
FAKE_READ_TARGET	hook/hook.c	14;"	d	file:
FAKE_WRITE_AFL	hook/hook.c	21;"	d	file:
FAULT_CRASH	afl-fuzz.c	/^  \/* 02 *\/ FAULT_CRASH,$/;"	e	enum:__anon3	file:
FAULT_ERROR	afl-fuzz.c	/^  \/* 03 *\/ FAULT_ERROR,$/;"	e	enum:__anon3	file:
FAULT_NOBITS	afl-fuzz.c	/^  \/* 05 *\/ FAULT_NOBITS$/;"	e	enum:__anon3	file:
FAULT_NOINST	afl-fuzz.c	/^  \/* 04 *\/ FAULT_NOINST,$/;"	e	enum:__anon3	file:
FAULT_NONE	afl-fuzz.c	/^  \/* 00 *\/ FAULT_NONE,$/;"	e	enum:__anon3	file:
FAULT_TMOUT	afl-fuzz.c	/^  \/* 01 *\/ FAULT_TMOUT,$/;"	e	enum:__anon3	file:
FF	afl-fuzz.c	994;"	d	file:
FLIP_BIT	afl-fuzz.c	5186;"	d	file:
FLIP_BIT	afl-fuzz.c	6771;"	d	file:
HAVE_AFFINITY	afl-fuzz.c	70;"	d	file:
MESSAGES_TO_STDOUT	afl-fuzz.c	24;"	d	file:
SP10	afl-fuzz.c	4073;"	d	file:
SP20	afl-fuzz.c	4074;"	d	file:
SP5	afl-fuzz.c	4072;"	d	file:
STAGE_ARITH16	afl-fuzz.c	/^  \/* 07 *\/ STAGE_ARITH16,$/;"	e	enum:__anon1	file:
STAGE_ARITH32	afl-fuzz.c	/^  \/* 08 *\/ STAGE_ARITH32,$/;"	e	enum:__anon1	file:
STAGE_ARITH8	afl-fuzz.c	/^  \/* 06 *\/ STAGE_ARITH8,$/;"	e	enum:__anon1	file:
STAGE_EXTRAS_AO	afl-fuzz.c	/^  \/* 14 *\/ STAGE_EXTRAS_AO,$/;"	e	enum:__anon1	file:
STAGE_EXTRAS_UI	afl-fuzz.c	/^  \/* 13 *\/ STAGE_EXTRAS_UI,$/;"	e	enum:__anon1	file:
STAGE_EXTRAS_UO	afl-fuzz.c	/^  \/* 12 *\/ STAGE_EXTRAS_UO,$/;"	e	enum:__anon1	file:
STAGE_FLIP1	afl-fuzz.c	/^  \/* 00 *\/ STAGE_FLIP1,$/;"	e	enum:__anon1	file:
STAGE_FLIP16	afl-fuzz.c	/^  \/* 04 *\/ STAGE_FLIP16,$/;"	e	enum:__anon1	file:
STAGE_FLIP2	afl-fuzz.c	/^  \/* 01 *\/ STAGE_FLIP2,$/;"	e	enum:__anon1	file:
STAGE_FLIP32	afl-fuzz.c	/^  \/* 05 *\/ STAGE_FLIP32,$/;"	e	enum:__anon1	file:
STAGE_FLIP4	afl-fuzz.c	/^  \/* 02 *\/ STAGE_FLIP4,$/;"	e	enum:__anon1	file:
STAGE_FLIP8	afl-fuzz.c	/^  \/* 03 *\/ STAGE_FLIP8,$/;"	e	enum:__anon1	file:
STAGE_HAVOC	afl-fuzz.c	/^  \/* 15 *\/ STAGE_HAVOC,$/;"	e	enum:__anon1	file:
STAGE_INTEREST16	afl-fuzz.c	/^  \/* 10 *\/ STAGE_INTEREST16,$/;"	e	enum:__anon1	file:
STAGE_INTEREST32	afl-fuzz.c	/^  \/* 11 *\/ STAGE_INTEREST32,$/;"	e	enum:__anon1	file:
STAGE_INTEREST8	afl-fuzz.c	/^  \/* 09 *\/ STAGE_INTEREST8,$/;"	e	enum:__anon1	file:
STAGE_SPLICE	afl-fuzz.c	/^  \/* 16 *\/ STAGE_SPLICE$/;"	e	enum:__anon1	file:
STAGE_VAL_BE	afl-fuzz.c	/^  \/* 02 *\/ STAGE_VAL_BE$/;"	e	enum:__anon2	file:
STAGE_VAL_LE	afl-fuzz.c	/^  \/* 01 *\/ STAGE_VAL_LE,$/;"	e	enum:__anon2	file:
STAGE_VAL_NONE	afl-fuzz.c	/^  \/* 00 *\/ STAGE_VAL_NONE,$/;"	e	enum:__anon2	file:
TARGET_WRITE_AFL	hook/hook.c	18;"	d	file:
TARGET_WRITE_FAKE	hook/hook.c	15;"	d	file:
TIMEOUT	hook/hook.c	9;"	d	file:
UR	afl-fuzz.c	/^static inline u32 UR(u32 limit) {$/;"	f	file:
_FILE_OFFSET_BITS	afl-fuzz.c	27;"	d	file:
_GNU_SOURCE	afl-fuzz.c	26;"	d	file:
_GNU_SOURCE	hook/hook.c	1;"	d	file:
_GNU_SOURCE	network/libpatched/network.c	1;"	d	file:
__FAVOR_BSD	interceptor.c	3;"	d	file:
__USE_BSD	interceptor.c	1;"	d	file:
a_extras	afl-fuzz.c	/^static struct extra_data* a_extras;   \/* Automatically selected extras    *\/$/;"	v	typeref:struct:extra_data	file:
a_extras_cnt	afl-fuzz.c	/^static u32 a_extras_cnt;              \/* Total number of tokens available *\/$/;"	v	file:
add_to_queue	afl-fuzz.c	/^static void add_to_queue(u8* fname, u32 len, u8 passed_det) {$/;"	f	file:
auto_changed	afl-fuzz.c	/^           auto_changed,              \/* Auto-generated tokens changed?   *\/$/;"	v
bH10	afl-fuzz.c	4069;"	d	file:
bH2	afl-fuzz.c	4067;"	d	file:
bH20	afl-fuzz.c	4070;"	d	file:
bH30	afl-fuzz.c	4071;"	d	file:
bH5	afl-fuzz.c	4068;"	d	file:
bSTG	afl-fuzz.c	4066;"	d	file:
bind_to_free_cpu	afl-fuzz.c	/^static void bind_to_free_cpu(void) {$/;"	f	file:
bitmap_changed	afl-fuzz.c	/^           bitmap_changed = 1,        \/* Time to update bitmap?           *\/$/;"	v
bitmap_size	afl-fuzz.c	/^  u32 bitmap_size,                    \/* Number of bits set in bitmap     *\/$/;"	m	struct:queue_entry	file:
blocks_eff_select	afl-fuzz.c	/^           blocks_eff_select;         \/* Blocks selected as fuzzable      *\/$/;"	v
blocks_eff_total	afl-fuzz.c	/^           blocks_eff_total,          \/* Blocks subject to effector maps  *\/$/;"	v
buffer	interceptor.c	/^static char *buffer;$/;"	v	file:
bytes_trim_in	afl-fuzz.c	/^           bytes_trim_in,             \/* Bytes coming into the trimmer    *\/$/;"	v
bytes_trim_out	afl-fuzz.c	/^           bytes_trim_out,            \/* Bytes coming outa the trimmer    *\/$/;"	v
cal_failed	afl-fuzz.c	/^  u8  cal_failed,                     \/* Calibration failed?              *\/$/;"	m	struct:queue_entry	file:
calculate_score	afl-fuzz.c	/^static u32 calculate_score(struct queue_entry* q) {$/;"	f	file:
calibrate_case	afl-fuzz.c	/^static u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem,$/;"	f	file:
check_asan_opts	afl-fuzz.c	/^static void check_asan_opts(void) {$/;"	f	file:
check_binary	afl-fuzz.c	/^EXP_ST void check_binary(u8* fname) {$/;"	f
check_cpu_governor	afl-fuzz.c	/^static void check_cpu_governor(void) {$/;"	f	file:
check_crash_handling	afl-fuzz.c	/^static void check_crash_handling(void) {$/;"	f	file:
check_if_tty	afl-fuzz.c	/^static void check_if_tty(void) {$/;"	f	file:
check_map_coverage	afl-fuzz.c	/^static void check_map_coverage(void) {$/;"	f	file:
check_term_size	afl-fuzz.c	/^static void check_term_size(void) {$/;"	f	file:
child_pid	afl-fuzz.c	/^           child_pid = -1,            \/* PID of the fuzzed program        *\/$/;"	v	file:
child_timed_out	afl-fuzz.c	/^                   child_timed_out;   \/* Traced process timed out?        *\/$/;"	v	file:
choose_block_len	afl-fuzz.c	/^static u32 choose_block_len(u32 limit) {$/;"	f	file:
classify_counts	afl-fuzz.c	/^static inline void classify_counts(u32* mem) {$/;"	f	file:
classify_counts	afl-fuzz.c	/^static inline void classify_counts(u64* mem) {$/;"	f	file:
clear_screen	afl-fuzz.c	/^                   clear_screen = 1,  \/* Window resized?                  *\/$/;"	v	file:
client_pid	afl-fuzz.c	/^static u32 client_pid;$/;"	v	file:
common_fuzz_stuff	afl-fuzz.c	/^EXP_ST u8 common_fuzz_stuff(char** argv, u8* out_buf, u32 len) {$/;"	f
compare_extras_len	afl-fuzz.c	/^static int compare_extras_len(const void* p1, const void* p2) {$/;"	f	file:
compare_extras_use_d	afl-fuzz.c	/^static int compare_extras_use_d(const void* p1, const void* p2) {$/;"	f	file:
could_be_arith	afl-fuzz.c	/^static u8 could_be_arith(u32 old_val, u32 new_val, u8 blen) {$/;"	f	file:
could_be_bitflip	afl-fuzz.c	/^static u8 could_be_bitflip(u32 xor_val) {$/;"	f	file:
could_be_interest	afl-fuzz.c	/^static u8 could_be_interest(u32 old_val, u32 new_val, u8 blen, u8 check_le) {$/;"	f	file:
count_bits	afl-fuzz.c	/^static u32 count_bits(u8* mem) {$/;"	f	file:
count_bytes	afl-fuzz.c	/^static u32 count_bytes(u8* mem) {$/;"	f	file:
count_class_lookup16	afl-fuzz.c	/^static u16 count_class_lookup16[65536];$/;"	v	file:
count_class_lookup8	afl-fuzz.c	/^static const u8 count_class_lookup8[256] = {$/;"	v	file:
count_non_255_bytes	afl-fuzz.c	/^static u32 count_non_255_bytes(u8* mem) {$/;"	f	file:
cpu_aff	afl-fuzz.c	/^static s32 cpu_aff = -1;			  \/* Selected CPU core                *\/$/;"	v	file:
cpu_core_count	afl-fuzz.c	/^static s32 cpu_core_count;            \/* CPU core count                   *\/$/;"	v	file:
crash_mode	afl-fuzz.c	/^           crash_mode,                \/* Crash mode! Yeah!                *\/$/;"	v
cull_queue	afl-fuzz.c	/^static void cull_queue(void) {$/;"	f	file:
cur_depth	afl-fuzz.c	/^           cur_depth,                 \/* Current path depth               *\/$/;"	v
cur_skipped_paths	afl-fuzz.c	/^           cur_skipped_paths,         \/* Abandoned inputs in cur cycle    *\/$/;"	v
current_entry	afl-fuzz.c	/^           current_entry,             \/* Current queue entry ID           *\/$/;"	v
current_size	interceptor.c	/^static int current_size;$/;"	v	file:
cycles_wo_finds	afl-fuzz.c	/^           cycles_wo_finds,           \/* Cycles without any new paths     *\/$/;"	v
data	afl-fuzz.c	/^  u8* data;                           \/* Dictionary token data            *\/$/;"	m	struct:extra_data	file:
debugMsg	network/state.c	/^void debugMsg(messages *obj)$/;"	f
debugProtocol	network/state.c	/^void debugProtocol(protocol *obj)$/;"	f
deferred_mode	afl-fuzz.c	/^           deferred_mode,             \/* Deferred forkserver mode?        *\/$/;"	v
deleteMsg	network/state.c	/^void deleteMsg(messages *obj)$/;"	f
deleteProtocol	network/state.c	/^void deleteProtocol(protocol *obj)$/;"	f
delete_files	afl-fuzz.c	/^static u8 delete_files(u8* path, u8* prefix) {$/;"	f	file:
depth	afl-fuzz.c	/^      depth;                          \/* Path depth                       *\/$/;"	m	struct:queue_entry	file:
describe_op	afl-fuzz.c	/^static u8* describe_op(u8 hnb) {$/;"	f	file:
destroy_extras	afl-fuzz.c	/^static void destroy_extras(void) {$/;"	f	file:
destroy_queue	afl-fuzz.c	/^EXP_ST void destroy_queue(void) {$/;"	f
detect_file_args	afl-fuzz.c	/^EXP_ST void detect_file_args(char** argv) {$/;"	f
dev_null_fd	afl-fuzz.c	/^           dev_null_fd = -1,          \/* Persistent fd for \/dev\/null      *\/$/;"	v	file:
dev_urandom_fd	afl-fuzz.c	/^           dev_urandom_fd = -1,       \/* Persistent fd for \/dev\/urandom   *\/$/;"	v	file:
doc_path	afl-fuzz.c	/^          *doc_path,                  \/* Path to documentation dir        *\/$/;"	v
dumb_mode	afl-fuzz.c	/^           dumb_mode,                 \/* Run in non-instrumented mode?    *\/$/;"	v
dump_data	network/state.c	/^unsigned char *dump_data(protocol *state, int *len)$/;"	f
dump_fuzzed_data	network/state.c	/^unsigned char *dump_fuzzed_data(protocol *state, unsigned char *data, unsigned int len, int *length)$/;"	f
evaluate	network/state.c	/^int evaluate(pid_t child_pid)$/;"	f
exec_cksum	afl-fuzz.c	/^      exec_cksum;                     \/* Checksum of the execution trace  *\/$/;"	m	struct:queue_entry	file:
exec_tmout	afl-fuzz.c	/^EXP_ST u32 exec_tmout = EXEC_TIMEOUT; \/* Configurable exec timeout (ms)   *\/$/;"	v
exec_us	afl-fuzz.c	/^  u64 exec_us,                        \/* Execution time (us)              *\/$/;"	m	struct:queue_entry	file:
extra_data	afl-fuzz.c	/^struct extra_data {$/;"	s	file:
extras	afl-fuzz.c	/^static struct extra_data* extras;     \/* Extra tokens to fuzz with        *\/$/;"	v	typeref:struct:extra_data	file:
extras_cnt	afl-fuzz.c	/^static u32 extras_cnt;                \/* Total number of tokens read      *\/$/;"	v	file:
fast_cal	afl-fuzz.c	/^           fast_cal;                  \/* Try to calibrate faster?         *\/$/;"	v
favored	afl-fuzz.c	/^      favored,                        \/* Currently favored?               *\/$/;"	m	struct:queue_entry	file:
find_start_position	afl-fuzz.c	/^static u32 find_start_position(void) {$/;"	f	file:
find_timeout	afl-fuzz.c	/^static void find_timeout(void) {$/;"	f	file:
fix_up_banner	afl-fuzz.c	/^static void fix_up_banner(u8* name) {$/;"	f	file:
fix_up_sync	afl-fuzz.c	/^static void fix_up_sync(void) {$/;"	f	file:
fname	afl-fuzz.c	/^  u8* fname;                          \/* File name for the test case      *\/$/;"	m	struct:queue_entry	file:
force_deterministic	afl-fuzz.c	/^           force_deterministic,       \/* Force deterministic stages?      *\/$/;"	v
forksrv_pid	afl-fuzz.c	/^static s32 forksrv_pid,               \/* PID of the fork server           *\/$/;"	v	file:
fs_redundant	afl-fuzz.c	/^      fs_redundant;                   \/* Marked as redundant in the fs?   *\/$/;"	m	struct:queue_entry	file:
fsrv_ctl_fd	afl-fuzz.c	/^           fsrv_ctl_fd,               \/* Fork server control pipe (write) *\/$/;"	v	file:
fsrv_st_fd	afl-fuzz.c	/^           fsrv_st_fd;                \/* Fork server status pipe (read)   *\/$/;"	v	file:
fuzz_one	afl-fuzz.c	/^static u8 fuzz_one(char** argv) {$/;"	f	file:
fuzzing_msg	afl-fuzz.c	/^static messages *fuzzing_msg;$/;"	v	file:
fuzzing_prot	afl-fuzz.c	/^static protocol *fuzzing_prot;$/;"	v	file:
getCurMsg	network/state.c	/^messages *getCurMsg(protocol *state)$/;"	f
getLenUntil	network/state.c	/^int getLenUntil(protocol *state, int index)$/;"	f
getMsg	network/state.c	/^messages *getMsg(protocol *state, int index)$/;"	f
getNxtMsg	network/state.c	/^messages *getNxtMsg(protocol *state)$/;"	f
get_core_count	afl-fuzz.c	/^static void get_core_count(void) {$/;"	f	file:
get_cur_time	afl-fuzz.c	/^static u64 get_cur_time(void) {$/;"	f	file:
get_cur_time_us	afl-fuzz.c	/^static u64 get_cur_time_us(void) {$/;"	f	file:
get_qemu_argv	afl-fuzz.c	/^static char** get_qemu_argv(u8* own_loc, char** argv, int argc) {$/;"	f	file:
get_runnable_processes	afl-fuzz.c	/^static double get_runnable_processes(void) {$/;"	f	file:
handicap	afl-fuzz.c	/^      handicap,                       \/* Number of queue cycles behind    *\/$/;"	m	struct:queue_entry	file:
handle_resize	afl-fuzz.c	/^static void handle_resize(int sig) {$/;"	f	file:
handle_signal	network/state.c	/^void handle_signal(int sig)$/;"	f
handle_skipreq	afl-fuzz.c	/^static void handle_skipreq(int sig) {$/;"	f	file:
handle_stop_sig	afl-fuzz.c	/^static void handle_stop_sig(int sig) {$/;"	f	file:
handle_timeout	afl-fuzz.c	/^static void handle_timeout(int sig) {$/;"	f	file:
hang_tmout	afl-fuzz.c	/^static u32 hang_tmout = EXEC_TIMEOUT; \/* Timeout used for hang det (ms)   *\/$/;"	v	file:
has_new_bits	afl-fuzz.c	/^static inline u8 has_new_bits(u8* virgin_map) {$/;"	f	file:
has_new_cov	afl-fuzz.c	/^      has_new_cov,                    \/* Triggers new coverage?           *\/$/;"	m	struct:queue_entry	file:
havoc_div	afl-fuzz.c	/^           havoc_div = 1;             \/* Cycle count divisor for havoc    *\/$/;"	v
hit_cnt	afl-fuzz.c	/^  u32 hit_cnt;                        \/* Use count in the corpus          *\/$/;"	m	struct:extra_data	file:
in_bitmap	afl-fuzz.c	/^          *in_bitmap,                 \/* Input bitmap                     *\/$/;"	v
in_dir	afl-fuzz.c	/^EXP_ST u8 *in_dir,                    \/* Input directory with test cases  *\/$/;"	v
in_place_resume	afl-fuzz.c	/^           in_place_resume,           \/* Attempt in-place resume?         *\/$/;"	v
init_count_class16	afl-fuzz.c	/^EXP_ST void init_count_class16(void) {$/;"	f
init_forkserver	afl-fuzz.c	/^EXP_ST void init_forkserver(char** argv) {$/;"	f
init_interceptor	interceptor.c	/^static void init_interceptor(const char *device)$/;"	f	file:
init_method	hook/hook.c	/^static __attribute__((constructor)) void init_method(void)$/;"	f	file:
init_method	network/libpatched/network.c	/^static __attribute__((constructor)) void init_method(void)$/;"	f	file:
interesting_16	afl-fuzz.c	/^static s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 };$/;"	v	file:
interesting_32	afl-fuzz.c	/^static s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 };$/;"	v	file:
interesting_8	afl-fuzz.c	/^static s8  interesting_8[]  = { INTERESTING_8 };$/;"	v	file:
ip_server	interceptor.c	/^static char *ip_server;$/;"	v	file:
kill_signal	afl-fuzz.c	/^           kill_signal,               \/* Signal that killed the child     *\/$/;"	v
last_crash_execs	afl-fuzz.c	/^           last_crash_execs,          \/* Exec counter at last crash       *\/$/;"	v
last_crash_time	afl-fuzz.c	/^           last_crash_time,           \/* Time for most recent crash (ms)  *\/$/;"	v
last_hang_time	afl-fuzz.c	/^           last_hang_time,            \/* Time for most recent hang (ms)   *\/$/;"	v
last_path_time	afl-fuzz.c	/^           last_path_time,            \/* Time for most recent path (ms)   *\/$/;"	v
len	afl-fuzz.c	/^  u32 len;                            \/* Dictionary token length          *\/$/;"	m	struct:extra_data	file:
len	afl-fuzz.c	/^  u32 len;                            \/* Input length                     *\/$/;"	m	struct:queue_entry	file:
libhook_path	afl-fuzz.c	/^u8 *libhook_path;$/;"	v
link_or_copy	afl-fuzz.c	/^static void link_or_copy(u8* old_path, u8* new_path) {$/;"	f	file:
loadFromMem	network/state.c	/^protocol *loadFromMem(char *tmp_buf, int totalSize)$/;"	f
load_auto	afl-fuzz.c	/^static void load_auto(void) {$/;"	f	file:
load_extras	afl-fuzz.c	/^static void load_extras(u8* dir) {$/;"	f	file:
load_extras_file	afl-fuzz.c	/^static void load_extras_file(u8* fname, u32* min_len, u32* max_len,$/;"	f	file:
locate_diffs	afl-fuzz.c	/^static void locate_diffs(u8* ptr1, u8* ptr2, u32 len, s32* first, s32* last) {$/;"	f	file:
main	afl-fuzz.c	/^int main(int argc, char** argv) {$/;"	f
main	interceptor.c	/^int main (int argc, char *argv[])$/;"	f
mark_as_det_done	afl-fuzz.c	/^static void mark_as_det_done(struct queue_entry* q) {$/;"	f	file:
mark_as_redundant	afl-fuzz.c	/^static void mark_as_redundant(struct queue_entry* q, u8 state) {$/;"	f	file:
mark_as_variable	afl-fuzz.c	/^static void mark_as_variable(struct queue_entry* q) {$/;"	f	file:
master_id	afl-fuzz.c	/^static u32 master_id, master_max;     \/* Master instance job splitting    *\/$/;"	v	file:
master_max	afl-fuzz.c	/^static u32 master_id, master_max;     \/* Master instance job splitting    *\/$/;"	v	file:
max_depth	afl-fuzz.c	/^           max_depth,                 \/* Max path depth                   *\/$/;"	v
maybe_add_auto	afl-fuzz.c	/^static void maybe_add_auto(u8* mem, u32 len) {$/;"	f	file:
maybe_delete_out_dir	afl-fuzz.c	/^static void maybe_delete_out_dir(void) {$/;"	f	file:
maybe_update_plot_file	afl-fuzz.c	/^static void maybe_update_plot_file(double bitmap_cvg, double eps) {$/;"	f	file:
mem_limit	afl-fuzz.c	/^EXP_ST u64 mem_limit  = MEM_LIMIT;    \/* Memory cap for child (MB)        *\/$/;"	v
memcmp_nocase	afl-fuzz.c	/^static inline u8 memcmp_nocase(u8* m1, u8* m2, u32 len) {$/;"	f	file:
minimize_bits	afl-fuzz.c	/^static void minimize_bits(u8* dst, u8* src) {$/;"	f	file:
my_packet_handler	interceptor.c	/^static void my_packet_handler(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)$/;"	f	file:
newMsg	network/state.c	/^messages *newMsg(int size, char *data, messages *prev, int done_det, int done_trim)$/;"	f
newProtocol	network/state.c	/^protocol *newProtocol(int current_msg, messages *start_msg, messages *end_msg, int size)$/;"	f
new_connection	network/utilities.c	/^int new_connection(const char *ip, unsigned int port)$/;"	f
next	afl-fuzz.c	/^  struct queue_entry *next,           \/* Next element, if any             *\/$/;"	m	struct:queue_entry	typeref:struct:queue_entry::queue_entry	file:
next_100	afl-fuzz.c	/^                     *next_100;       \/* 100 elements ahead               *\/$/;"	m	struct:queue_entry	typeref:struct:queue_entry::	file:
next_p2	afl-fuzz.c	/^static u32 next_p2(u32 val) {$/;"	f	file:
no_arith	afl-fuzz.c	/^           no_arith,                  \/* Skip most arithmetic ops         *\/$/;"	v
no_cpu_meter_red	afl-fuzz.c	/^           no_cpu_meter_red,          \/* Feng shui on the status screen   *\/$/;"	v
no_forkserver	afl-fuzz.c	/^           no_forkserver,             \/* Disable forkserver?              *\/$/;"	v
not_on_tty	afl-fuzz.c	/^           not_on_tty,                \/* stdout is not a tty              *\/$/;"	v
nuke_resume_dir	afl-fuzz.c	/^static void nuke_resume_dir(void) {$/;"	f	file:
orig_cmdline	afl-fuzz.c	/^          *orig_cmdline;              \/* Original command line            *\/$/;"	v
orig_read	hook/hook.c	/^static orig_read_f orig_read = NULL;$/;"	v	file:
orig_read_f	hook/hook.c	/^typedef ssize_t (*orig_read_f)(int fd, void *buf, size_t count);$/;"	t	file:
orig_recv	hook/hook.c	/^static orig_recv_f orig_recv = NULL;$/;"	v	file:
orig_recv	network/libpatched/network.c	/^static orig_recv_f orig_recv = NULL;$/;"	v	file:
orig_recv_f	hook/hook.c	/^typedef ssize_t (*orig_recv_f)(int fd, void *buf, size_t len, int flags);$/;"	t	file:
orig_recv_f	network/libpatched/network.c	/^typedef int (*orig_recv_f)(int fd, void *buf, size_t len, int flags);$/;"	t	file:
orig_socket	network/libpatched/network.c	/^static orig_socket_f orig_socket = NULL;$/;"	v	file:
orig_socket_f	network/libpatched/network.c	/^typedef int (*orig_socket_f)(int domain, int type, int protocol);$/;"	t	file:
out_dir	afl-fuzz.c	/^          *out_dir,                   \/* Working & output directory       *\/$/;"	v
out_dir_fd	afl-fuzz.c	/^           out_dir_fd = -1;           \/* FD of the lock file              *\/$/;"	v	file:
out_fd	afl-fuzz.c	/^static s32 out_fd,                    \/* Persistent fd for out_file       *\/$/;"	v	file:
out_file	afl-fuzz.c	/^          *out_file,                  \/* File to fuzz, if any             *\/$/;"	v
outfile	interceptor.c	/^static char *outfile;$/;"	v	file:
passed_det	afl-fuzz.c	/^      passed_det,                     \/* Deterministic stages passed?     *\/$/;"	m	struct:queue_entry	file:
pending_favored	afl-fuzz.c	/^           pending_favored,           \/* Pending favored paths            *\/$/;"	v
pending_not_fuzzed	afl-fuzz.c	/^           pending_not_fuzzed,        \/* Queued but not done yet          *\/$/;"	v
perform_dry_run	afl-fuzz.c	/^static void perform_dry_run(char** argv) {$/;"	f	file:
persistent_mode	afl-fuzz.c	/^           persistent_mode,           \/* Running in persistent mode?      *\/$/;"	v
pivot_inputs	afl-fuzz.c	/^static void pivot_inputs(void) {$/;"	f	file:
plot_file	afl-fuzz.c	/^static FILE* plot_file;               \/* Gnuplot output file              *\/$/;"	v	file:
port_server	afl-fuzz.c	/^static u16 port_server;$/;"	v	file:
port_server	interceptor.c	/^static int port_server;$/;"	v	file:
post_handler	afl-fuzz.c	/^static u8* (*post_handler)(u8* buf, u32* len);$/;"	v	file:
pprint	network/state.c	/^void pprint(const char *prefix, char *s, int size)$/;"	f
prev_child_pid	afl-fuzz.c	/^s32 prev_child_pid;$/;"	v
protocol_server	interceptor.c	/^static u_char protocol_server;$/;"	v	file:
q_prev100	afl-fuzz.c	/^                          *q_prev100; \/* Previous 100 marker              *\/$/;"	v	typeref:struct:	file:
qemu_mode	afl-fuzz.c	/^           qemu_mode,                 \/* Running in QEMU mode?            *\/$/;"	v
queue	afl-fuzz.c	/^static struct queue_entry *queue,     \/* Fuzzing queue (linked list)      *\/$/;"	v	typeref:struct:queue_entry	file:
queue_cur	afl-fuzz.c	/^                          *queue_cur, \/* Current offset within the queue  *\/$/;"	v	typeref:struct:	file:
queue_cycle	afl-fuzz.c	/^           queue_cycle,               \/* Queue round counter              *\/$/;"	v
queue_entry	afl-fuzz.c	/^struct queue_entry {$/;"	s	file:
queue_top	afl-fuzz.c	/^                          *queue_top, \/* Top of the list                  *\/$/;"	v	typeref:struct:	file:
queued_at_start	afl-fuzz.c	/^           queued_at_start,           \/* Total number of initial inputs   *\/$/;"	v
queued_discovered	afl-fuzz.c	/^           queued_discovered,         \/* Items discovered during this run *\/$/;"	v
queued_favored	afl-fuzz.c	/^           queued_favored,            \/* Paths deemed favorable           *\/$/;"	v
queued_imported	afl-fuzz.c	/^           queued_imported,           \/* Items imported via -S            *\/$/;"	v
queued_paths	afl-fuzz.c	/^EXP_ST u32 queued_paths,              \/* Total number of queued testcases *\/$/;"	v
queued_variable	afl-fuzz.c	/^           queued_variable,           \/* Testcases with variable behavior *\/$/;"	v
queued_with_cov	afl-fuzz.c	/^           queued_with_cov,           \/* Paths with new coverage bytes    *\/$/;"	v
rand_cnt	afl-fuzz.c	/^static u32 rand_cnt;                  \/* Random number counter            *\/$/;"	v	file:
read_bitmap	afl-fuzz.c	/^EXP_ST void read_bitmap(u8* fname) {$/;"	f
read_testcases	afl-fuzz.c	/^static void read_testcases(void) {$/;"	f	file:
recv	hook/hook.c	/^ssize_t recv(int sockfd, void *buf, size_t len, int flags)$/;"	f
recv	network/libpatched/network.c	/^ssize_t recv(int fd, void *buf, size_t len, int flags)$/;"	f
recvAll	network/utilities.c	/^int recvAll(int sockfd) {$/;"	f
remove_shm	afl-fuzz.c	/^static void remove_shm(void) {$/;"	f	file:
resuming_fuzz	afl-fuzz.c	/^           resuming_fuzz,             \/* Resuming an older fuzzing job?   *\/$/;"	v
run_over10m	afl-fuzz.c	/^           run_over10m,               \/* Run time over 10 minutes?        *\/$/;"	v
run_target	afl-fuzz.c	/^static u8 run_target(char** argv, u32 timeout) {$/;"	f	file:
save_auto	afl-fuzz.c	/^static void save_auto(void) {$/;"	f	file:
save_cmdline	afl-fuzz.c	/^static void save_cmdline(u32 argc, char** argv) {$/;"	f	file:
save_if_interesting	afl-fuzz.c	/^static u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault) {$/;"	f	file:
score_changed	afl-fuzz.c	/^           score_changed,             \/* Scoring for favorites changed?   *\/$/;"	v
sendAll	network/utilities.c	/^void sendAll(int sockfd, unsigned char *msg, int len)$/;"	f
serialize	network/state.c	/^void serialize(protocol *state, int cur_index, char *msg, int len, char *filename)$/;"	f
setup_communications	network/state.c	/^void setup_communications(u32 *client_fd, const char *out_file, u16 port)$/;"	f
setup_dirs_fds	afl-fuzz.c	/^EXP_ST void setup_dirs_fds(void) {$/;"	f
setup_post	afl-fuzz.c	/^static void setup_post(void) {$/;"	f	file:
setup_shm	afl-fuzz.c	/^EXP_ST void setup_shm(void) {$/;"	f
setup_signal_handlers	afl-fuzz.c	/^EXP_ST void setup_signal_handlers(void) {$/;"	f
setup_stdio_file	afl-fuzz.c	/^EXP_ST void setup_stdio_file(void) {$/;"	f
shm_id	afl-fuzz.c	/^static s32 shm_id;                    \/* ID of the SHM region             *\/$/;"	v	file:
show_init_stats	afl-fuzz.c	/^static void show_init_stats(void) {$/;"	f	file:
show_stats	afl-fuzz.c	/^static void show_stats(void) {$/;"	f	file:
shuffle_ptrs	afl-fuzz.c	/^static void shuffle_ptrs(void** ptrs, u32 cnt) {$/;"	f	file:
shuffle_queue	afl-fuzz.c	/^           shuffle_queue,             \/* Shuffle input queue?             *\/$/;"	v
sig_handler	interceptor.c	/^static void sig_handler(int sig)$/;"	f	file:
simplify_lookup	afl-fuzz.c	/^static const u8 simplify_lookup[256] = { $/;"	v	file:
simplify_trace	afl-fuzz.c	/^static void simplify_trace(u32* mem) {$/;"	f	file:
simplify_trace	afl-fuzz.c	/^static void simplify_trace(u64* mem) {$/;"	f	file:
single_msg	afl-fuzz.c	/^static u32 single_msg;$/;"	v	file:
skip_deterministic	afl-fuzz.c	/^EXP_ST u8  skip_deterministic,        \/* Skip deterministic stages?       *\/$/;"	v
skip_requested	afl-fuzz.c	/^           skip_requested,            \/* Skip request, via SIGUSR1        *\/$/;"	v
socket	network/libpatched/network.c	/^int socket(int domain, int type, int protocol)$/;"	f
splicing_with	afl-fuzz.c	/^static s32 splicing_with = -1;        \/* Splicing with which test case?   *\/$/;"	v	file:
stage_cur	afl-fuzz.c	/^static s32 stage_cur, stage_max;      \/* Stage progression                *\/$/;"	v	file:
stage_cur_byte	afl-fuzz.c	/^static s32 stage_cur_byte,            \/* Byte offset of current stage op  *\/$/;"	v	file:
stage_cur_val	afl-fuzz.c	/^           stage_cur_val;             \/* Value used for stage op          *\/$/;"	v	file:
stage_cycles	afl-fuzz.c	/^           stage_cycles[32];          \/* Execs per fuzz stage             *\/$/;"	v	file:
stage_finds	afl-fuzz.c	/^static u64 stage_finds[32],           \/* Patterns found per fuzz stage    *\/$/;"	v	file:
stage_max	afl-fuzz.c	/^static s32 stage_cur, stage_max;      \/* Stage progression                *\/$/;"	v	file:
stage_name	afl-fuzz.c	/^static u8 *stage_name = "init",       \/* Name of the current fuzz stage   *\/$/;"	v	file:
stage_short	afl-fuzz.c	/^          *stage_short,               \/* Short stage name                 *\/$/;"	v	file:
stage_val_type	afl-fuzz.c	/^static u8  stage_val_type;            \/* Value type (STAGE_VAL_*)         *\/$/;"	v	file:
start_time	afl-fuzz.c	/^           start_time,                \/* Unix start time (ms)             *\/$/;"	v
state	interceptor.c	/^static protocol *state;$/;"	v	file:
stats_update_freq	afl-fuzz.c	/^static u32 stats_update_freq = 1;     \/* Stats update frequency (execs)   *\/$/;"	v	file:
stop_soon	afl-fuzz.c	/^static volatile u8 stop_soon,         \/* Ctrl-C pressed?                  *\/$/;"	v	file:
subseq_tmouts	afl-fuzz.c	/^static u32 subseq_tmouts;             \/* Number of timeouts in a row      *\/$/;"	v	file:
sync_dir	afl-fuzz.c	/^          *sync_dir,                  \/* Synchronization directory        *\/$/;"	v
sync_fuzzers	afl-fuzz.c	/^static void sync_fuzzers(char** argv) {$/;"	f	file:
sync_id	afl-fuzz.c	/^          *sync_id,                   \/* Fuzzer ID                        *\/$/;"	v
syncing_case	afl-fuzz.c	/^static u32 syncing_case;              \/* Syncing with case #...           *\/$/;"	v	file:
syncing_party	afl-fuzz.c	/^          *syncing_party;             \/* Currently syncing with...        *\/$/;"	v	file:
target_path	afl-fuzz.c	/^          *target_path,               \/* Path to target binary            *\/$/;"	v
tc_ref	afl-fuzz.c	/^  u32 tc_ref;                         \/* Trace bytes ref count            *\/$/;"	m	struct:queue_entry	file:
term_too_small	afl-fuzz.c	/^           term_too_small,            \/* terminal dimensions too small    *\/$/;"	v
terminated	afl-fuzz.c	/^u8 terminated;$/;"	v
timeout_given	afl-fuzz.c	/^           timeout_given,             \/* Specific timeout given?          *\/$/;"	v
top_rated	afl-fuzz.c	/^  top_rated[MAP_SIZE];                \/* Top entries for bitmap bytes     *\/$/;"	v	typeref:struct:queue_entry	file:
total_bitmap_entries	afl-fuzz.c	/^           total_bitmap_entries;      \/* Number of bitmaps counted        *\/$/;"	v	file:
total_bitmap_size	afl-fuzz.c	/^static u64 total_bitmap_size,         \/* Total bit count for all bitmaps  *\/$/;"	v	file:
total_cal_cycles	afl-fuzz.c	/^           total_cal_cycles;          \/* Total calibration cycles         *\/$/;"	v	file:
total_cal_us	afl-fuzz.c	/^static u64 total_cal_us,              \/* Total calibration time (us)      *\/$/;"	v	file:
total_crashes	afl-fuzz.c	/^EXP_ST u64 total_crashes,             \/* Total number of crashes          *\/$/;"	v
total_execs	afl-fuzz.c	/^           total_execs,               \/* Total execve() calls             *\/$/;"	v
total_tmouts	afl-fuzz.c	/^           total_tmouts,              \/* Total number of timeouts         *\/$/;"	v
trace_bits	afl-fuzz.c	/^EXP_ST u8* trace_bits;                \/* SHM with instrumentation bitmap  *\/$/;"	v
trace_mini	afl-fuzz.c	/^  u8* trace_mini;                     \/* Trace bytes, if kept             *\/$/;"	m	struct:queue_entry	file:
trim_case	afl-fuzz.c	/^static u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf) {$/;"	f	file:
trim_done	afl-fuzz.c	/^      trim_done,                      \/* Trimmed?                         *\/$/;"	m	struct:queue_entry	file:
trim_execs	afl-fuzz.c	/^           trim_execs,                \/* Execs done to trim input files   *\/$/;"	v
unique_crashes	afl-fuzz.c	/^           unique_crashes,            \/* Crashes with unique signatures   *\/$/;"	v
unique_hangs	afl-fuzz.c	/^           unique_hangs,              \/* Hangs with unique signatures     *\/$/;"	v
unique_tmouts	afl-fuzz.c	/^           unique_tmouts,             \/* Timeouts with unique signatures  *\/$/;"	v
unserialize	network/state.c	/^protocol *unserialize(char *filename)$/;"	f
update_bitmap_score	afl-fuzz.c	/^static void update_bitmap_score(struct queue_entry* q) {$/;"	f	file:
usage	afl-fuzz.c	/^static void usage(u8* argv0) {$/;"	f	file:
usage	interceptor.c	/^static void usage(int err)$/;"	f	file:
use_banner	afl-fuzz.c	/^          *use_banner,                \/* Display banner                   *\/$/;"	v
use_splicing	afl-fuzz.c	/^           use_splicing,              \/* Recombine input files?           *\/$/;"	v
useless_at_start	afl-fuzz.c	/^           useless_at_start,          \/* Number of useless starting paths *\/$/;"	v
uses_asan	afl-fuzz.c	/^           uses_asan,                 \/* Target uses ASAN?                *\/$/;"	v
var_behavior	afl-fuzz.c	/^      var_behavior,                   \/* Variable behavior?               *\/$/;"	m	struct:queue_entry	file:
var_byte_count	afl-fuzz.c	/^           var_byte_count,            \/* Bitmap bytes with var behavior   *\/$/;"	v
var_bytes	afl-fuzz.c	/^static u8  var_bytes[MAP_SIZE];       \/* Bytes that appear to be variable *\/$/;"	v	file:
virgin_bits	afl-fuzz.c	/^EXP_ST u8  virgin_bits[MAP_SIZE],     \/* Regions yet untouched by fuzzing *\/$/;"	v
virgin_crash	afl-fuzz.c	/^           virgin_crash[MAP_SIZE];    \/* Bits we haven't seen in crashes  *\/$/;"	v
virgin_tmout	afl-fuzz.c	/^           virgin_tmout[MAP_SIZE],    \/* Bits we haven't seen in tmouts   *\/$/;"	v
was_fuzzed	afl-fuzz.c	/^      was_fuzzed,                     \/* Had any fuzzing done yet?        *\/$/;"	m	struct:queue_entry	file:
write_bitmap	afl-fuzz.c	/^EXP_ST void write_bitmap(void) {$/;"	f
write_crash_readme	afl-fuzz.c	/^static void write_crash_readme(void) {$/;"	f	file:
write_stats_file	afl-fuzz.c	/^static void write_stats_file(double bitmap_cvg, double stability, double eps) {$/;"	f	file:
write_to_testcase	afl-fuzz.c	/^static void write_to_testcase(void* mem, u32 len) {$/;"	f	file:
write_with_gap	afl-fuzz.c	/^static void write_with_gap(void* mem, u32 len, u32 skip_at, u32 skip_len) {$/;"	f	file:
